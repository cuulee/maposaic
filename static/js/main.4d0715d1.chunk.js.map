{"version":3,"sources":["Mapozaic/paint.worker.ts","Mapozaic/Mapozaic.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Worker","styles","width","height","position","paintWorker","PaintWorker","showMapboxCanvas","mapboxCanvas","document","getElementById","cvs","style","opacity","MapboxGLMap","useState","map","setMap","mapContainer","useRef","isLoading","setIsLoading","paintMozaic","a","getCanvas","gl","getContext","console","log","webglWidth","drawingBufferWidth","webglHeight","drawingBufferHeight","viewportWidth","viewportHeight","mapozaicCanvas","setAttribute","toString","mapozaicContext","imageData","getImageData","mapozaicData","data","mapboxPixels","Uint8Array","readPixels","RGBA","UNSIGNED_BYTE","onmessage","e","set","putImageData","postMessage","useEffect","mapboxgl","accessToken","process","Map","container","current","zoom","center","lng","lat","on","resize","loaded","isMoving","isZooming","terminate","initializeMap","className","id","ref","el","App","Mapozaic","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.4d0715d1.chunk.js","sourcesContent":["module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"57e96b48d5855b781de5.worker.js\");\n};","import React, { useState, useRef, useEffect, MutableRefObject } from 'react'\nimport mapboxgl from 'mapbox-gl'\n// eslint-disable-next-line\nimport PaintWorker from 'worker-loader!./paint.worker'\n\nimport './style.css'\n\n// eslint-disable-next-line\nconst token: string = process.env['REACT_APP_MAPBOX_TOKEN'] || ''\n\nconst styles = {\n  width: '100vw',\n  height: 'calc(100vh)',\n  position: 'absolute',\n} as React.CSSProperties\n\nexport type RGBColor = { r: number; g: number; b: number }\nexport type imagePoint = { x: number; y: number }\n\nlet paintWorker = new PaintWorker()\n\nconst showMapboxCanvas = (): void => {\n  const mapboxCanvas = document.getElementById('mapbox-cvs') as HTMLCanvasElement\n  const cvs = document.getElementById('mapozaic-cvs') as HTMLCanvasElement\n  mapboxCanvas.style.opacity = '1'\n  cvs.style.opacity = '0'\n}\n\nconst MapboxGLMap = (): JSX.Element => {\n  const [map, setMap] = useState<mapboxgl.Map | null>(null)\n  const mapContainer = useRef<HTMLDivElement | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n\n  const paintMozaic = async (map: mapboxgl.Map): Promise<void> => {\n    setIsLoading(true)\n    showMapboxCanvas()\n    const mapboxCanvas = map.getCanvas()\n    const gl = mapboxCanvas.getContext('webgl')\n    if (!gl) {\n      console.log('pas de gl')\n      return\n    }\n    const webglWidth = gl.drawingBufferWidth\n    const webglHeight = gl.drawingBufferHeight\n    const viewportWidth = webglWidth\n    const viewportHeight = webglHeight\n\n    const mapozaicCanvas = document.getElementById('mapozaic-cvs') as HTMLCanvasElement\n    mapozaicCanvas.setAttribute('width', viewportWidth.toString())\n    mapozaicCanvas.setAttribute('height', viewportHeight.toString())\n    const mapozaicContext = mapozaicCanvas.getContext('2d')\n    if (!mapozaicContext) {\n      return\n    }\n    const imageData = mapozaicContext.getImageData(0, 0, mapozaicCanvas.width, mapozaicCanvas.height)\n    const mapozaicData = imageData.data\n\n    const mapboxPixels = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4)\n    gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, mapboxPixels)\n\n    paintWorker.onmessage = function (e): void {\n      imageData.data.set(e.data)\n      mapozaicContext.putImageData(imageData, 0, 0)\n      const mapboxElement = document.getElementById('mapbox-cvs') as HTMLCanvasElement\n      mapboxElement.style.opacity = '0'\n      mapozaicCanvas.style.opacity = '1'\n      setIsLoading(false)\n    }\n    paintWorker.postMessage({ mapboxPixels, mapozaicData, webglWidth, webglHeight, viewportHeight, viewportWidth })\n  }\n\n  useEffect(() => {\n    mapboxgl.accessToken = token\n    const initializeMap = (mapContainer: MutableRefObject<HTMLDivElement | null>): void => {\n      const map = new mapboxgl.Map({\n        container: mapContainer.current ? mapContainer.current : '',\n        style: 'mapbox://styles/cartapuce/ck831v1pi187r1inxwf7np531', // stylesheet location\n        // style: 'mapbox://styles/mapbox/streets-v11',\n        zoom: 12,\n        center: {\n          lng: 2.338272,\n          lat: 48.858796,\n        },\n      })\n\n      map.on('load', () => {\n        setMap(map)\n        map.resize()\n      })\n      map.on('dragstart', showMapboxCanvas)\n      map.on('zoomstart', showMapboxCanvas)\n      map.on('render', () => {\n        if (!map.loaded() || map.isMoving() || map.isZooming()) {\n          return\n        }\n        paintWorker.terminate()\n        paintWorker = new PaintWorker()\n        paintMozaic(map)\n      })\n    }\n\n    if (!map && mapContainer) {\n      initializeMap(mapContainer)\n    }\n  }, [map])\n\n  return (\n    <div className=\"container\">\n      <canvas className=\"mozaic\" width=\"300\" height=\"300\" id=\"mapozaic-cvs\" />\n      <div id=\"mapbox-cvs\" className=\"mapbox-cvs\" ref={(el) => (mapContainer.current = el)} style={styles} />\n      {isLoading && <div className=\"loading\">Loading...</div>}\n    </div>\n  )\n}\n\nexport default MapboxGLMap\n","import React from 'react'\nimport './App.css'\nimport Mapozaic from './Mapozaic/Mapozaic'\n\nfunction App() {\n  return <Mapozaic />\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.')\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister()\n      })\n      .catch((error) => {\n        console.error(error.message)\n      })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}